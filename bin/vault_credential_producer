#!/bin/bash

ME="$0"

fatal()
{
    echo
    echo "$ME: $@"
    exit 1
} >&2

OPTS="$(condor_config_val SEC_CREDENTIAL_GETTOKEN_OPTS 2>/dev/null)"
if [ -z "$OPTS" ] && [ -z "$HTGETTOKENOPTS" ]; then
    fatal 'Neither SEC_CREDENTIAL_GETTOKEN_OPTS condor value nor $HTGETTOKENS environment set'
fi

# Keep the standard duration vault token in $VTOKEN.condor, to make
#  sure that credmon has a long-duration one, but copy it to $VTOKEN if a
#  new one is generated.
VTOKEN="/tmp/vt_u`id -u`"

FIRSTOPTS="--vaulttokenttl=28d $OPTS --vaulttokeninfile=$VTOKEN.condor --vaulttokenfile=/dev/stdout"

# First attempt to get a token quietly without oidc
VAULTTOKEN="`htgettoken $FIRSTOPTS --nooidc -q`"
if [ $? != 0 ]; then
    # OIDC authentication probably needed, so remove -q to tell the user
    #  what is happening
    # Start with newline to get past condor_submit's in-progress message
    echo >&2
    VAULTTOKEN="`htgettoken $FIRSTOPTS`"
    if [ $? != 0 ]; then
	fatal "htgettoken failed"
    fi
fi

if [ -n "$VAULTTOKEN" ]; then
    if ! [[ "$VAULTTOKEN" =~ ^s\..* ]]; then
	fatal "htgettoken returned something not a vault token: $VAULTTOKEN"
    fi
    # A new long-duration vault token was received
    # Exchange it for a shorter duration vault token on disk
    echo "$VAULTTOKEN"|htgettoken $OPTS --nobearertoken -q --vaulttokeninfile=/dev/stdin --vaulttokenfile=$VTOKEN.condor
    if [ $? != 0 ]; then
	fatal "Failed to exchange vault token"
    fi

    # Now copy $VTOKEN.condor to $VTOKEN atomically
    TMPFILE="`mktemp $VTOKEN.XXXXXXXXXX`"
    cat $VTOKEN.condor >$TMPFILE
    mv $TMPFILE $VTOKEN
else
    # No new token was generated, tell vault-credmon to reuse the old one
    VAULTTOKEN="REUSE_TOKEN"
fi 

# Finally, send the long-duration vault token to credmon via stdout
echo "$VAULTTOKEN"
